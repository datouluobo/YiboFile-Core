# 库路径绝对路径修复与双面板刷新优化

**版本**: v1.0.331  
**日期**: 2026-02-06  
**修复类型**: Bug Fix & Enhancement

## 问题描述

### 问题1：库文件路径识别错误
当拖拽文件到库时，出现"文件未找到"错误。错误日志显示路径包含 `bin\Debug\net8.0-windows\win-x64`，说明程序将相对路径误解析为相对于当前执行目录的路径。

**错误示例**：
```
24.jpeg: Could not find a part of the path 'F:\Download\GitHub\YiboFile\YiboFile-Core\bin\Debug\net8.0-windows\win-x64\Test\24.jpeg'.
```

**根本原因**：
- 数据库中可能存储了相对路径（如 `Test`）
- 在读取和使用库路径时未强制转换为绝对路径
- .NET 默认将相对路径解析为相对于当前工作目录（程序的执行目录）

### 问题2：文件操作后未刷新另一个面板
在双面板模式下，当在一个面板执行文件操作（复制、移动等）后，另一个面板不会自动刷新，导致文件列表不同步。

## 修复方案

### 1. 库路径绝对路径转换（多层防御）

#### 1.1 存储时转换（LibraryService.cs）
在所有添加库路径的入口点，将路径转换为绝对路径后再保存到数据库：

```csharp
// AddLibraryPath 方法
string fullPath = path;
try
{
    fullPath = Path.GetFullPath(path);
}
catch (Exception ex)
{
    System.Diagnostics.Debug.WriteLine($"[LibraryService] Path.GetFullPath failed for {path}: {ex.Message}");
}
_repository.AddLibraryPath(libraryId, fullPath);

// AddLibrary 方法（初始路径）
if (!string.IsNullOrWhiteSpace(initialPath))
{
    string fullPath = initialPath;
    try { fullPath = Path.GetFullPath(initialPath); }
    catch (Exception ex) { /* 日志记录 */ }
    _repository.AddLibraryPath(libraryId, fullPath);
}

// ImportLibrariesFromJson 方法
foreach (var path in item.Paths)
{
    if (!string.IsNullOrWhiteSpace(path))
    {
        string fullPath = path;
        try { fullPath = Path.GetFullPath(path); } catch { }
        _repository.AddLibraryPath(libId, fullPath);
    }
}
```

#### 1.2 读取时转换（SqliteLibraryRepository.cs）
在从数据库读取库路径时（防御性编程，处理旧数据）：

```csharp
// GetAllLibraries, GetAllLibrariesAsync, GetLibrary, GetLibraryAsync
while (pathReader.Read()) // 或 await pathReader.ReadAsync()
{
    var path = pathReader.GetString(0);
    try
    {
        path = Path.GetFullPath(path);
    }
    catch (Exception ex)
    {
        System.Diagnostics.Debug.WriteLine($"[SqliteLibraryRepository] Path.GetFullPath failed for {path}: {ex.Message}");
    }
    paths.Add(path);
}
```

#### 1.3 使用时转换（MainWindow.DragDrop.cs）
在拖拽到库时，再次确保使用绝对路径：

```csharp
private void NavigationItem_Drop(object sender, DragEventArgs e)
{
    // ...
    if (lib != null && lib.Paths != null && lib.Paths.Count > 0)
    {
        targetPath = lib.Paths[0];
        try
        {
            targetPath = Path.GetFullPath(targetPath);
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"[DragDrop] Path.GetFullPath failed for library path {targetPath}: {ex.Message}");
        }
    }
    // ...
}
```

#### 1.4 加载时转换（FileListService.cs）
在加载库文件时，确保路径是绝对路径：

```csharp
// LoadFileSystemItemsAsync - ProtocolType.Library 分支
var absoluteLibPaths = lib.Paths?.Select(p => {
    try { return Path.GetFullPath(p); } catch { return p; }
}).ToList() ?? new List<string>();

var actualPaths = string.IsNullOrEmpty(subPath)
    ? absoluteLibPaths
    : absoluteLibPaths.Select(p => Path.Combine(p, subPath)).Where(Directory.Exists).ToList();
```

#### 1.5 **复制粘贴操作时转换（最重要）**

**发现的问题**：用户报告问题出现在复制粘贴操作，而不是拖拽操作。

在 `FileOperationContext.cs` 中，`GetEffectiveTargetPath()` 方法用于获取粘贴操作的目标路径：

```csharp
public string GetEffectiveTargetPath()
{
    string result = null;
    
    if (!string.IsNullOrEmpty(TargetPath) && Directory.Exists(TargetPath))
    {
        result = TargetPath;
    }
    else if (CurrentLibrary?.Paths?.Count > 0)
    {
        foreach (var path in CurrentLibrary.Paths)
        {
            if (Directory.Exists(path))
            {
                result = path;
                break;
            }
        }
    }

    // 确保返回的路径是绝对路径，防止库路径是相对路径导致的文件未找到错误
    if (!string.IsNullOrEmpty(result))
    {
        try
        {
            result = Path.GetFullPath(result);
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"[FileOperationContext] Path.GetFullPath failed for {result}: {ex.Message}");
        }
    }

    return result;
}
```

在 `LibraryOperationContext.cs` 中的 `GetTargetPath()` 方法也做了同样的处理：

```csharp
public string GetTargetPath()
{
    if (_currentLibrary == null || _currentLibrary.Paths == null || _currentLibrary.Paths.Count == 0)
    {
        return null;
    }

    var firstPath = _currentLibrary.Paths[0];
    
    // 确保路径是绝对路径
    try
    {
        firstPath = Path.GetFullPath(firstPath);
    }
    catch (Exception ex)
    {
        System.Diagnostics.Debug.WriteLine($"[LibraryOperationContext] Path.GetFullPath failed for {firstPath}: {ex.Message}");
    }
    
    if (!Directory.Exists(firstPath))
    {
        return null;
    }

    // ... 其他逻辑
    return firstPath;
}
```

### 2. 双面板刷新优化（MainWindow.DragDrop.cs）

增强 `DragDropManager` 的刷新逻辑，确保文件操作后所有相关面板都能刷新：

```csharp
manager.RequestRefresh = () =>
{
    try
    {
        // 刷新源面板（执行操作的面板）
        if (isPrimary)
        {
            if (_currentLibrary != null)
                LoadLibraryFiles(_currentLibrary);
            else
                LoadCurrentDirectory();
        }
        else
        {
            var secondTab = _secondTabService?.ActiveTab;
            if (secondTab != null && !string.IsNullOrEmpty(secondTab.Path) && Directory.Exists(secondTab.Path))
            {
                SecondFileBrowser_PathChanged(this, secondTab.Path);
            }
        }

        // 如果处于双面板模式，也刷新另一个面板
        if (IsDualListMode)
        {
            if (isPrimary && SecondFileBrowser != null)
            {
                // 刷新副面板
                var secondTab = _secondTabService?.ActiveTab;
                if (secondTab != null && !string.IsNullOrEmpty(secondTab.Path) && Directory.Exists(secondTab.Path))
                {
                    SecondFileBrowser_PathChanged(this, secondTab.Path);
                }
            }
            else if (!isPrimary && FileBrowser != null)
            {
                // 刷新主面板
                if (_currentLibrary != null)
                    LoadLibraryFiles(_currentLibrary);
                else
                    LoadCurrentDirectory();
            }
        }
    }
    catch { }
};
```

## 修改文件清单

| 文件 | 修改内容 |
|------|---------|
| `Services/Features/LibraryService.cs` | 在 AddLibraryPath、AddLibrary、ImportLibrariesFromJson 中添加路径转换 |
| `Services/Data/Repositories/SqliteLibraryRepository.cs` | 在 GetAllLibraries、GetAllLibrariesAsync、GetLibrary、GetLibraryAsync 中添加路径转换 |
| `Services/FileSystem/FileList/FileListService.cs` | 在 LoadFileSystemItemsAsync 的库路径处理中添加绝对路径转换 |
| `MainWindow.DragDrop.cs` | 在 NavigationItem_Drop 中添加路径转换，优化 SetupDragDropManager 的刷新逻辑 |
| **`Services/FileOperations/Core/FileOperationContext.cs`** | **在 GetEffectiveTargetPath 中添加路径转换（修复复制粘贴问题的关键）** |
| **`Services/FileSystem/FileOperations/LibraryOperationContext.cs`** | **在 GetTargetPath 中添加路径转换（修复复制粘贴问题的关键）** |

## 测试建议

### 测试场景1：库路径识别（复制粘贴操作）
1. 创建一个新库，添加一个文件夹路径（如 `F:\Test`）
2. 在文件浏览器中选中一些文件
3. **复制（Ctrl+C）这些文件**
4. 切换到库模式，选择刚创建的库
5. **粘贴（Ctrl+V）文件**
6. 验证文件是否正确复制到 `F:\Test` 目录，而不是 `bin\Debug\net8.0-windows\win-x64\Test`
7. 检查数据库中存储的路径是否为绝对路径

### 测试场景2：旧数据兼容
1. 如果数据库中存在旧的相对路径数据（如 `Test`）
2. 重启应用，查看是否能正确转换为绝对路径
3. 验证拖拽操作是否正常工作

### 测试场景3：双面板刷新
1. 开启双面板模式
2. 主面板和副面板都打开同一个目录
3. 在主面板执行文件复制/移动操作
4. 验证副面板是否自动刷新显示新文件
5. 反向测试：在副面板执行操作，主面板是否刷新

### 测试场景4：跨面板操作
1. 开启双面板模式
2. 主面板显示目录A，副面板显示目录B
3. 从主面板拖拽文件到副面板
4. 验证两个面板是否都正确刷新

## 技术要点

### 多层防御策略
采用"写入时转换 + 读取时转换 + 使用时转换"的三层防御策略，确保：
1. **数据一致性**：所有新写入的数据都是绝对路径
2. **向后兼容**：能够处理数据库中可能存在的旧相对路径数据
3. **运行时保障**：即使前两层有遗漏，在实际使用时也能正确转换

### Path.GetFullPath 的作用
- 将相对路径转换为绝对路径
- 规范化路径分隔符（统一为反斜杠 `\` 或正斜杠 `/`）
- 解析 `.` 和 `..` 等特殊路径元素
- 处理UNC路径和驱动器路径

### 异常处理
所有 `Path.GetFullPath` 调用都用 try-catch 包裹，因为：
- 路径可能包含非法字符
- 路径可能超过系统最大长度限制
- 确保程序不会因路径转换失败而崩溃

## 相关Issue/PR

- 修复了库文件路径识别错误导致的"文件未找到"问题
- 优化了双面板模式下的文件列表刷新机制

## 后续优化建议

1. **数据库迁移脚本**：创建一个一次性迁移脚本，将数据库中所有相对路径批量转换为绝对路径
2. **路径验证**：在添加库路径时，验证路径是否存在，给用户即时反馈
3. **相对路径支持**：如果有特殊需求（如便携式应用），可以考虑显式支持相对路径，但需要明确基础路径
4. **性能优化**：缓存绝对路径转换结果，避免重复计算
5. **智能刷新**：只刷新受影响的目录，而不是无差别刷新所有面板
