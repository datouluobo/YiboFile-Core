# 副面板文件操作修复

**版本**: v1.0.332  
**日期**: 2026-02-07  
**修复类型**: Bug Fix

## 问题描述

用户报告：**副列表（第二个面板）不能正常复制粘贴删除**。具体表现为：
1. 操作副列表时，主列表会自动刷新
2. 副列表本身不能正常刷新
3. 副列表的库路径无法正确识别

**根本原因**：
`GetActiveFileOperationContext()` 方法在处理副面板时存在两个严重问题：
1. **库识别错误**：当副面板显示库时，`targetLibrary` 被强制设置为 `null`（代码中有 `TODO` 注释）
2. **刷新逻辑缺陷**：虽然能判断当前焦点面板，但库信息缺失导致文件操作无法正确执行

## 修复方案

### 修改文件
`MainWindow.Initialization.cs` - `GetActiveFileOperationContext()` 方法

### 修复前代码（问题代码）

```csharp
private FileOperationContext GetActiveFileOperationContext()
{
    // 确定当前活动的面板
    bool useSecond = IsDualListMode && IsSecondPaneFocused;

    var targetBrowser = useSecond ? SecondFileBrowser : FileBrowser;
    var targetPath = useSecond ? SecondFileBrowser?.AddressText : _currentPath;

    // TODO: Determine library for second pane if separate
    var targetLibrary = useSecond ? null : _currentLibrary;  // ❌ 问题：副面板的库信息丢失

    return new FileOperationContext
    {
        TargetPath = targetPath,
        CurrentLibrary = targetLibrary,
        OwnerWindow = this,
        RefreshCallback = () =>
        {
            if (useSecond)
            {
                if (SecondFileBrowser != null && !string.IsNullOrEmpty(SecondFileBrowser.AddressText))
                    LoadSecondFileBrowserDirectory(SecondFileBrowser.AddressText);
            }
            else
            {
                RefreshFileList();
            }
        }
    };
}
```

### 修复后代码

```csharp
private FileOperationContext GetActiveFileOperationContext()
{
    // 确定当前活动的面板
    bool useSecond = IsDualListMode && IsSecondPaneFocused;

    var targetBrowser = useSecond ? SecondFileBrowser : FileBrowser;
    var targetPath = useSecond ? SecondFileBrowser?.AddressText : _currentPath;

    // ✅ 解析副面板的库信息（如果副面板显示的是库）
    Library targetLibrary = null;
    if (useSecond)
    {
        // 从副面板的地址栏解析库
        if (!string.IsNullOrEmpty(targetPath) && targetPath.StartsWith("lib://", StringComparison.OrdinalIgnoreCase))
        {
            var libName = targetPath.Substring(6);
            var slashIndex = libName.IndexOf('/');
            if (slashIndex > 0)
            {
                libName = libName.Substring(0, slashIndex);
            }
            
            // 从 LibraryService 获取库信息
            targetLibrary = _libraryService?.GetAllLibraries()?.FirstOrDefault(l => 
                string.Equals(l.Name, libName, StringComparison.OrdinalIgnoreCase));
        }
    }
    else
    {
        targetLibrary = _currentLibrary;
    }

    return new FileOperationContext
    {
        TargetPath = targetPath,
        CurrentLibrary = targetLibrary,
        OwnerWindow = this,
        RefreshCallback = () =>
        {
            if (useSecond)
            {
                // ✅ 只刷新副面板
                if (SecondFileBrowser != null && !string.IsNullOrEmpty(SecondFileBrowser.AddressText))
                    LoadSecondFileBrowserDirectory(SecondFileBrowser.AddressText);
            }
            else
            {
                // ✅ 只刷新主面板
                RefreshFileList();
            }
        }
    };
}
```

## 修复要点

### 1. 副面板库识别

**问题**：副面板显示 `lib://LibraryName/SubPath` 时，系统无法识别这是一个库。

**解决方案**：
1. 检测地址栏是否以 `lib://` 开头
2. 从地址栏提取库名称（去除子路径）
3. 通过 `LibraryService.GetAllLibraries()` 查找对应的库对象
4. 将找到的库对象赋值给 `targetLibrary`

**关键代码**：
```csharp
var libName = targetPath.Substring(6);  // 去掉 "lib://"
var slashIndex = libName.IndexOf('/');  // 找到子路径分隔符
if (slashIndex > 0)
{
    libName = libName.Substring(0, slashIndex);  // 只保留库名
}
targetLibrary = _libraryService?.GetAllLibraries()?.FirstOrDefault(l => 
    string.Equals(l.Name, libName, StringComparison.OrdinalIgnoreCase));
```

### 2. 焦点面板判断

**关键逻辑**：
```csharp
bool useSecond = IsDualListMode && IsSecondPaneFocused;
```

- `IsDualListMode`：检查是否处于双面板模式
- `IsSecondPaneFocused`：检查焦点是否在副面板

### 3. 精确刷新控制

**之前的问题**：操作副面板时，主面板也会刷新。

**修复后的行为**：
- 操作主面板 → 只刷新主面板 (`RefreshFileList()`)
- 操作副面板 → 只刷新副面板 (`LoadSecondFileBrowserDirectory()`)

## 测试建议

### 测试场景1：副面板库操作
1. 开启双面板模式
2. 主面板打开一个普通文件夹（如 `D:\Temp`）
3. 副面板打开一个库（如 `lib://MyLibrary`）
4. **聚焦副面板**（点击副面板的文件列表）
5. 在副面板选中文件，执行复制（Ctrl+C）
6. 在副面板执行粘贴（Ctrl+V）
7. **验证**：
   - 文件应该被复制到库的实际路径
   - 副面板自动刷新显示新文件
   - 主面板**不应该**刷新

### 测试场景2：副面板普通文件夹操作
1. 开启双面板模式
2. 主面板和副面板都打开普通文件夹
3. **聚焦副面板**
4. 在副面板执行复制粘贴删除操作
5. **验证**：
   - 操作成功
   - 副面板刷新
   - 主面板不刷新

### 测试场景3：主副面板交叉操作
1. 开启双面板模式
2. 主面板打开库A，副面板打开库B
3. 在主面板复制文件
4. **切换焦点到副面板**
5. 在副面板粘贴
6. **验证**：文件被粘贴到库B，且只有副面板刷新

### 测试场景4：副面板删除操作
1. 开启双面板模式
2. 副面板打开库
3. **聚焦副面板**
4. 选中文件，按 Delete
5. **验证**：
   - 文件被删除
   - 副面板刷新
   - 主面板不刷新

## 技术要点

### 地址栏协议解析

副面板的 `AddressText` 可能包含多种协议：
- `lib://LibraryName` - 库根目录
- `lib://LibraryName/SubFolder` - 库的子目录
- `D:\Path\To\Folder` - 普通文件夹路径
- `tag://TagName` - 标签过滤（未来支持）

本次修复只处理了 `lib://` 协议，其他协议会正常返回 `targetLibrary = null`。

### 刷新回调的设计

`RefreshCallback` 是一个无参数的 `Action`，它捕获了 `useSecond` 变量：
- 这是闭包（Closure）的应用
- 确保刷新时使用的是操作时的面板状态，而不是刷新时的状态

### 为什么不直接存储副面板的库状态？

**设计考虑**：
- 主面板有明确的 `_currentLibrary` 字段
- 副面板是动态的，可能随时切换
- 通过地址栏动态解析更灵活，避免状态同步问题

## 相关代码关联

### 调用链

```
用户操作副面板 → 复制/粘贴/删除
    ↓
FileOperationService.PasteAsync() / DeleteAsync()
    ↓
contextProvider() （即 GetActiveFileOperationContext()）
    ↓
检查 IsSecondPaneFocused
    ↓
解析副面板地址栏 → 获取库信息
    ↓
创建正确的 FileOperationContext
    ↓
执行文件操作
    ↓
RefreshCallback() → 只刷新副面板
```

### 相关实现文件

| 文件 | 作用 |
|------|------|
| `MainWindow.Initialization.cs` | 提供 `GetActiveFileOperationContext()` 方法 |
| `MainWindow.LayoutMode.cs` | 提供 `IsSecondPaneFocused` 属性 |
| `Services/FileOperations/FileOperationService.cs` | 使用上下文执行文件操作 |
| `Services/FileOperations/Core/FileOperationContext.cs` | 定义操作上下文结构 |
| `Services/Features/LibraryService.cs` | 提供 `GetAllLibraries()` 查询库 |

## 后续优化建议

1. **性能优化**：缓存库列表，避免每次操作都调用 `GetAllLibraries()`
2. **标签支持**：扩展协议解析，支持 `tag://` 协议
3. **错误处理**：当库不存在时给出明确提示
4. **状态管理**：考虑为副面板也添加 `_secondCurrentLibrary` 字段
5. **测试覆盖**：添加单元测试验证协议解析逻辑
