# 技术文档：副面板信息栏与窗口状态修复及卡死故障排除

> **修复日期**: 2026-02-03
> **涉及模块**: ConfigurationService, MainWindow, WindowLifecycleHandler

## 一、 问题描述与状态

| 问题 | 状态 | 描述 |
|------|------|------|
| **1. 启动时副文件信息区不显示** | ✅ **已解决** | 通过调整 `MainWindow.xaml.cs` 中的初始化顺序解决。 |
| **2. 窗口状态持久化** | ✅ **已修复** | 发现并修复了启动期间配置被错误状态覆盖的问题。 |
| **3. 副栏选中导航-库程序卡死** | ✅ **已修复** | 点击侧边栏“库”按钮时程序无响应（死循环）。通过优化事件处理逻辑修复。 |

## 二、 深度故障分析：窗口状态为何丢失？

通过植入的调试日志，我们成功捕获了导致窗口最大化失效的“凶手”。日志时间线如下：

1.  **15:14:03.37** `ConfigManager.Load`: 读取配置 `IsMaximized=True`。这是正确的上次状态。
2.  **15:14:03.97** `ConfigManager.Save`: **异常保存发生！** 此时窗口正在初始化，尚未完全渲染，状态仍为 `Normal`。但由于某些 ViewModel 的属性绑定触发了变更，导致配置服务将当前的 `Normal` 状态写入了磁盘，**覆盖了正确的配置**。
3.  **15:14:05.24** `MainWindow.ContentRendered`: 窗口渲染完成。此时再读取配置，已经是被篡改后的 `False` 了，因此没有执行最大化恢复。

**结论**：这是典型的“初始化竞争”问题。UI 组件在准备就绪前就触发了通过数据绑定反向写入配置的逻辑。

## 三、 解决方案：启动保护机制

为了彻底解决此类问题，我们在 `ConfigurationService` 中引入了**启动保护 (Startup Protection)** 机制：

1.  **默认禁止保存**：`ConfigurationService` 初始化时，设置 `_isSaveSuppressed = true`。此时任何属性变更触发的保存请求（`TriggerDebouncedSave`）都会被拦截并丢弃。
2.  **显式启用**：只有当 `MainWindow` 触发 `ContentRendered` 事件，意味着窗口已完全显示且布局稳定后，才调用 `ConfigurationService.EnableSaving()` 解除封锁。
3.  **效果**：启动过程中的所有不稳定中间状态变更都不会污染配置文件，确保了配置的纯洁性。

## 四、 修改的文件清单

1.  `f:\Download\GitHub\YiboFile\YiboFile-Core\Services\Config\ConfigurationService.cs` (实现启动保护逻辑)
2.  `f:\Download\GitHub\YiboFile\YiboFile-Core\MainWindow.xaml.cs` (在渲染完成后启用保存)
3.  `f:\Download\GitHub\YiboFile\YiboFile-Core\Handlers\WindowLifecycleHandler.cs` (辅助日志)

请运行程序验证。窗口现在应该能完美记住最大化状态了。
